// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/walkersumida/aws-sso-google/credential"
	"sync"
	"time"
)

// Ensure, that CredentialerMock does implement credential.Credentialer.
// If this is not the case, regenerate this file with moq.
var _ credential.Credentialer = &CredentialerMock{}

// CredentialerMock is a mock implementation of credential.Credentialer.
//
//	func TestSomethingThatUsesCredentialer(t *testing.T) {
//
//		// make and configure a mocked credential.Credentialer
//		mockedCredentialer := &CredentialerMock{
//			IsExpiredFunc: func() bool {
//				panic("mock out the IsExpired method")
//			},
//			LoadFunc: func() error {
//				panic("mock out the Load method")
//			},
//			OutputFunc: func() (string, error) {
//				panic("mock out the Output method")
//			},
//			SaveFunc: func() error {
//				panic("mock out the Save method")
//			},
//			SetAccessKeyIDFunc: func(s *string)  {
//				panic("mock out the SetAccessKeyID method")
//			},
//			SetExpirationFunc: func(timeMoqParam *time.Time)  {
//				panic("mock out the SetExpiration method")
//			},
//			SetSecretAccessKeyFunc: func(s *string)  {
//				panic("mock out the SetSecretAccessKey method")
//			},
//			SetSessionTokenFunc: func(s *string)  {
//				panic("mock out the SetSessionToken method")
//			},
//		}
//
//		// use mockedCredentialer in code that requires credential.Credentialer
//		// and then make assertions.
//
//	}
type CredentialerMock struct {
	// IsExpiredFunc mocks the IsExpired method.
	IsExpiredFunc func() bool

	// LoadFunc mocks the Load method.
	LoadFunc func() error

	// OutputFunc mocks the Output method.
	OutputFunc func() (string, error)

	// SaveFunc mocks the Save method.
	SaveFunc func() error

	// SetAccessKeyIDFunc mocks the SetAccessKeyID method.
	SetAccessKeyIDFunc func(s *string)

	// SetExpirationFunc mocks the SetExpiration method.
	SetExpirationFunc func(timeMoqParam *time.Time)

	// SetSecretAccessKeyFunc mocks the SetSecretAccessKey method.
	SetSecretAccessKeyFunc func(s *string)

	// SetSessionTokenFunc mocks the SetSessionToken method.
	SetSessionTokenFunc func(s *string)

	// calls tracks calls to the methods.
	calls struct {
		// IsExpired holds details about calls to the IsExpired method.
		IsExpired []struct {
		}
		// Load holds details about calls to the Load method.
		Load []struct {
		}
		// Output holds details about calls to the Output method.
		Output []struct {
		}
		// Save holds details about calls to the Save method.
		Save []struct {
		}
		// SetAccessKeyID holds details about calls to the SetAccessKeyID method.
		SetAccessKeyID []struct {
			// S is the s argument value.
			S *string
		}
		// SetExpiration holds details about calls to the SetExpiration method.
		SetExpiration []struct {
			// TimeMoqParam is the timeMoqParam argument value.
			TimeMoqParam *time.Time
		}
		// SetSecretAccessKey holds details about calls to the SetSecretAccessKey method.
		SetSecretAccessKey []struct {
			// S is the s argument value.
			S *string
		}
		// SetSessionToken holds details about calls to the SetSessionToken method.
		SetSessionToken []struct {
			// S is the s argument value.
			S *string
		}
	}
	lockIsExpired          sync.RWMutex
	lockLoad               sync.RWMutex
	lockOutput             sync.RWMutex
	lockSave               sync.RWMutex
	lockSetAccessKeyID     sync.RWMutex
	lockSetExpiration      sync.RWMutex
	lockSetSecretAccessKey sync.RWMutex
	lockSetSessionToken    sync.RWMutex
}

// IsExpired calls IsExpiredFunc.
func (mock *CredentialerMock) IsExpired() bool {
	if mock.IsExpiredFunc == nil {
		panic("CredentialerMock.IsExpiredFunc: method is nil but Credentialer.IsExpired was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsExpired.Lock()
	mock.calls.IsExpired = append(mock.calls.IsExpired, callInfo)
	mock.lockIsExpired.Unlock()
	return mock.IsExpiredFunc()
}

// IsExpiredCalls gets all the calls that were made to IsExpired.
// Check the length with:
//
//	len(mockedCredentialer.IsExpiredCalls())
func (mock *CredentialerMock) IsExpiredCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsExpired.RLock()
	calls = mock.calls.IsExpired
	mock.lockIsExpired.RUnlock()
	return calls
}

// Load calls LoadFunc.
func (mock *CredentialerMock) Load() error {
	if mock.LoadFunc == nil {
		panic("CredentialerMock.LoadFunc: method is nil but Credentialer.Load was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLoad.Lock()
	mock.calls.Load = append(mock.calls.Load, callInfo)
	mock.lockLoad.Unlock()
	return mock.LoadFunc()
}

// LoadCalls gets all the calls that were made to Load.
// Check the length with:
//
//	len(mockedCredentialer.LoadCalls())
func (mock *CredentialerMock) LoadCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLoad.RLock()
	calls = mock.calls.Load
	mock.lockLoad.RUnlock()
	return calls
}

// Output calls OutputFunc.
func (mock *CredentialerMock) Output() (string, error) {
	if mock.OutputFunc == nil {
		panic("CredentialerMock.OutputFunc: method is nil but Credentialer.Output was just called")
	}
	callInfo := struct {
	}{}
	mock.lockOutput.Lock()
	mock.calls.Output = append(mock.calls.Output, callInfo)
	mock.lockOutput.Unlock()
	return mock.OutputFunc()
}

// OutputCalls gets all the calls that were made to Output.
// Check the length with:
//
//	len(mockedCredentialer.OutputCalls())
func (mock *CredentialerMock) OutputCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOutput.RLock()
	calls = mock.calls.Output
	mock.lockOutput.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *CredentialerMock) Save() error {
	if mock.SaveFunc == nil {
		panic("CredentialerMock.SaveFunc: method is nil but Credentialer.Save was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc()
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedCredentialer.SaveCalls())
func (mock *CredentialerMock) SaveCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// SetAccessKeyID calls SetAccessKeyIDFunc.
func (mock *CredentialerMock) SetAccessKeyID(s *string) {
	if mock.SetAccessKeyIDFunc == nil {
		panic("CredentialerMock.SetAccessKeyIDFunc: method is nil but Credentialer.SetAccessKeyID was just called")
	}
	callInfo := struct {
		S *string
	}{
		S: s,
	}
	mock.lockSetAccessKeyID.Lock()
	mock.calls.SetAccessKeyID = append(mock.calls.SetAccessKeyID, callInfo)
	mock.lockSetAccessKeyID.Unlock()
	mock.SetAccessKeyIDFunc(s)
}

// SetAccessKeyIDCalls gets all the calls that were made to SetAccessKeyID.
// Check the length with:
//
//	len(mockedCredentialer.SetAccessKeyIDCalls())
func (mock *CredentialerMock) SetAccessKeyIDCalls() []struct {
	S *string
} {
	var calls []struct {
		S *string
	}
	mock.lockSetAccessKeyID.RLock()
	calls = mock.calls.SetAccessKeyID
	mock.lockSetAccessKeyID.RUnlock()
	return calls
}

// SetExpiration calls SetExpirationFunc.
func (mock *CredentialerMock) SetExpiration(timeMoqParam *time.Time) {
	if mock.SetExpirationFunc == nil {
		panic("CredentialerMock.SetExpirationFunc: method is nil but Credentialer.SetExpiration was just called")
	}
	callInfo := struct {
		TimeMoqParam *time.Time
	}{
		TimeMoqParam: timeMoqParam,
	}
	mock.lockSetExpiration.Lock()
	mock.calls.SetExpiration = append(mock.calls.SetExpiration, callInfo)
	mock.lockSetExpiration.Unlock()
	mock.SetExpirationFunc(timeMoqParam)
}

// SetExpirationCalls gets all the calls that were made to SetExpiration.
// Check the length with:
//
//	len(mockedCredentialer.SetExpirationCalls())
func (mock *CredentialerMock) SetExpirationCalls() []struct {
	TimeMoqParam *time.Time
} {
	var calls []struct {
		TimeMoqParam *time.Time
	}
	mock.lockSetExpiration.RLock()
	calls = mock.calls.SetExpiration
	mock.lockSetExpiration.RUnlock()
	return calls
}

// SetSecretAccessKey calls SetSecretAccessKeyFunc.
func (mock *CredentialerMock) SetSecretAccessKey(s *string) {
	if mock.SetSecretAccessKeyFunc == nil {
		panic("CredentialerMock.SetSecretAccessKeyFunc: method is nil but Credentialer.SetSecretAccessKey was just called")
	}
	callInfo := struct {
		S *string
	}{
		S: s,
	}
	mock.lockSetSecretAccessKey.Lock()
	mock.calls.SetSecretAccessKey = append(mock.calls.SetSecretAccessKey, callInfo)
	mock.lockSetSecretAccessKey.Unlock()
	mock.SetSecretAccessKeyFunc(s)
}

// SetSecretAccessKeyCalls gets all the calls that were made to SetSecretAccessKey.
// Check the length with:
//
//	len(mockedCredentialer.SetSecretAccessKeyCalls())
func (mock *CredentialerMock) SetSecretAccessKeyCalls() []struct {
	S *string
} {
	var calls []struct {
		S *string
	}
	mock.lockSetSecretAccessKey.RLock()
	calls = mock.calls.SetSecretAccessKey
	mock.lockSetSecretAccessKey.RUnlock()
	return calls
}

// SetSessionToken calls SetSessionTokenFunc.
func (mock *CredentialerMock) SetSessionToken(s *string) {
	if mock.SetSessionTokenFunc == nil {
		panic("CredentialerMock.SetSessionTokenFunc: method is nil but Credentialer.SetSessionToken was just called")
	}
	callInfo := struct {
		S *string
	}{
		S: s,
	}
	mock.lockSetSessionToken.Lock()
	mock.calls.SetSessionToken = append(mock.calls.SetSessionToken, callInfo)
	mock.lockSetSessionToken.Unlock()
	mock.SetSessionTokenFunc(s)
}

// SetSessionTokenCalls gets all the calls that were made to SetSessionToken.
// Check the length with:
//
//	len(mockedCredentialer.SetSessionTokenCalls())
func (mock *CredentialerMock) SetSessionTokenCalls() []struct {
	S *string
} {
	var calls []struct {
		S *string
	}
	mock.lockSetSessionToken.RLock()
	calls = mock.calls.SetSessionToken
	mock.lockSetSessionToken.RUnlock()
	return calls
}
